"""Tools for managing design state."""

import logging
import json
from pathlib import Path
from typing import Dict, Any, List
from core.state import design_state

logger = logging.getLogger(__name__)


async def get_design_state() -> Dict[str, Any]:
    """
    Get the current state of the anaerobic digester design process.
    
    Returns the complete design state including all collected parameters,
    configurations, and results from various design stages.
    
    Returns:
        Dictionary containing:
        - basis_of_design: Collected design parameters
        - adm1_state: ADM1 state variables (if estimated)
        - heuristic_config: Heuristic sizing configuration (if calculated)
        - simulation_results: QSDsan ADM1+sulfur simulation summary (if available)
        - last_simulation_summary: Lightweight summary of cached simulation (if available)
        - economic_results: Economic analysis results (if available)
        - completion_status: Status of each design phase
    """
    try:
        # Determine completion status
        completion_status = {
            "basis_of_design": len(design_state.basis_of_design) > 0,
            "adm1_estimation": len(design_state.adm1_state) > 0,
            "heuristic_sizing": len(design_state.heuristic_config) > 0,
            "simulation": len(design_state.simulation_results) > 0,
            "economic_analysis": len(design_state.economic_results) > 0
        }
        
        # Calculate overall progress
        completed = sum(1 for v in completion_status.values() if v)
        total = len(completion_status)
        progress = f"{int(100 * completed / total)}%"
        
        # Get next steps
        next_steps = get_next_steps(completion_status)
        
        return {
            "status": "success",
            **design_state.to_dict(),
            "completion_status": completion_status,
            "overall_progress": progress,
            "next_steps": next_steps
        }
        
    except Exception as e:
        logger.error(f"Error in get_design_state: {str(e)}")
        return {
            "status": "error",
            "message": f"Failed to retrieve design state: {str(e)}"
        }


async def reset_design() -> Dict[str, Any]:
    """
    Reset the anaerobic digester design state.

    Clears all stored parameters and results to start a new design session.

    Returns:
        Confirmation of reset operation
    """
    try:
        design_state.reset()

        return {
            "status": "success",
            "message": "Design state has been reset",
            "state": design_state.to_dict()
        }

    except Exception as e:
        logger.error(f"Error in reset_design: {str(e)}")
        return {
            "status": "error",
            "message": f"Failed to reset design state: {str(e)}"
        }


async def load_adm1_state(file_path: str = "./adm1_state.json") -> Dict[str, Any]:
    """
    Load ADM1 state from JSON file into design_state.

    This tool loads ADM1 state variables that were generated by the
    ADM1-State-Variable-Estimator Codex MCP server or manually created.

    Args:
        file_path: Path to JSON file with ADM1 state (default: ./adm1_state.json)

    Returns:
        Status and number of components loaded
    """
    try:
        file_path = Path(file_path)

        if not file_path.exists():
            return {
                "status": "error",
                "message": f"File not found: {file_path}",
                "suggestion": "Run ADM1-State-Variable-Estimator Codex MCP first to generate ADM1 state"
            }

        # Load JSON
        with open(file_path, 'r') as f:
            adm1_data = json.load(f)

        # Handle [value, unit, description] format from Codex
        clean_state = {}
        for key, value in adm1_data.items():
            if isinstance(value, list) and len(value) > 0:
                clean_state[key] = float(value[0])
            elif isinstance(value, dict) and 'value' in value:
                clean_state[key] = float(value['value'])
            else:
                clean_state[key] = float(value)

        # Store in design_state
        design_state.adm1_state = clean_state

        return {
            "status": "success",
            "components_loaded": len(clean_state),
            "message": f"Loaded {len(clean_state)} ADM1 components from {file_path}",
            "components": list(clean_state.keys()),
            "file_path": str(file_path.absolute())
        }

    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in {file_path}: {e}")
        return {
            "status": "error",
            "message": f"Invalid JSON format: {str(e)}"
        }
    except Exception as e:
        logger.error(f"Error loading ADM1 state: {e}", exc_info=True)
        return {
            "status": "error",
            "message": f"Failed to load ADM1 state: {str(e)}"
        }


def get_next_steps(completion_status: Dict[str, bool]) -> List[str]:
    """Determine next steps based on completion status."""
    next_steps = []
    
    if not completion_status["basis_of_design"]:
        next_steps.append("Use elicit_basis_of_design to collect design parameters")
    elif not completion_status["adm1_estimation"]:
        next_steps.append("Use mcp__ADM1-State-Variable-Estimator__codex to characterize feedstock and generate ADM1 state variables, then validate with validate_adm1_state")
    elif not completion_status["heuristic_sizing"]:
        next_steps.append("Use heuristic_sizing_ad to size the digester")
    elif not completion_status["simulation"]:
        next_steps.append("Use simulate_ad_system_tool to run QSDsan dynamic simulation with ADM1+sulfur model")
    elif not completion_status["economic_analysis"]:
        next_steps.append("Economic analysis pending")
    else:
        next_steps.append("Design complete! Review results with get_design_state")
    
    return next_steps